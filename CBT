using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.Intrinsics.X86;


namespace CBT_sudoku
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Sudoku sudoku = new Sudoku(" 8 0 0 0 0 0 0 0 0 0 0 3 6 0 0 0 0 0 0 7 0 0 9 0 2 0 0 0 5 0 0 0 7 0 0 0 0 0 0 0 4 5 7 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 6 8 0 0 8 5 0 0 0 1 0 0 9 0 0 0 0 4 0 0");
            //Sudoku sudoku = new Sudoku(" 0 0 3 0 2 0 6 0 0 9 0 0 3 0 5 0 0 1 0 0 1 8 0 6 4 0 0 0 0 8 1 0 2 9 0 0 7 0 0 0 0 0 0 0 8 0 0 6 7 0 8 2 0 0 0 0 2 6 0 9 5 0 0 8 0 0 2 0 3 0 0 9 0 0 5 0 1 0 3 0 0");
            Console.WriteLine(sudoku);
            SudokuSolver solver = new SudokuSolver();
            solver.Solve("FC", sudoku);
        }
    }

    class SudokuSolver
    {
        public void Solve(string methode, Sudoku sudoku)
        {
            // Check of de doorgevoerde methode geldig is
            if (methode != "CBT" && methode != "FC" && methode != "FCMCV") Console.WriteLine("Voer een geldige methode in");
            // Als hij geldig is, los de sudoku op met de juiste methode
            else
            {
                Stopwatch timer = new Stopwatch();
                timer.Start();
                bool oplosbaar = true;

                switch (methode)
                {
                    case "CBT":
                        oplosbaar = BackTrackSolve(0, 0, sudoku);
                        break;

                    case "FC":
                        oplosbaar = ForwardCheckSolve(sudoku);
                        break;

                    case "FCMCV":
                        oplosbaar = false;
                        break;
                }

                timer.Stop();
                // Print het resulaat
                if (oplosbaar)
                {
                    Console.WriteLine(sudoku);
                    Console.WriteLine($"Opgelost in {timer.ElapsedMilliseconds} ms");
                }
                else
                {
                    Console.WriteLine("geen oplossing");
                }
            }
        }

        private static bool BackTrackSolve(int x, int y, Sudoku sudoku)
        {
            // Check of we voorbij het einde van de rij zijn
            if (x == 9)
            {
                // Check of we bij het einde van de sudoku zijn, dus of we klaar zijn
                if (y == 8) return true;

                // Anders naar volgende rij gaan
                y++;
                x = 0;
            }

            // Als het vakje vast is hoeven we hem niet te checken
            if (sudoku.vakjes[x, y] != 0) return BackTrackSolve(x + 1, y, sudoku);

            // Check voor alle getallen 1-9 of het getal legaal is in het vakje
            for (int getal = 1; getal < 10; getal++)
            {
                if (Legaal(x, y, getal, sudoku))
                {
                    // Als het getal legaal is vullen we hem in en gaan we verder met zoeken
                    sudoku.vakjes[x, y] = getal;
                    if (BackTrackSolve(x + 1, y, sudoku)) return true; // Return zorgt ervoor dat we uit de recursie gaan als we klaar zijn
                }
            }

            // Geen oplossing in deze tak: zet vakje weer op 0 en return false (backtrack)
            sudoku.vakjes[x, y] = 0;
            return false;
        }

        private static bool ForwardCheckSolve(Sudoku sudoku)
        {
            // We moeten per vakje een lijst bijhouden met mogelijke getallen: voor elk vakje 9 bools
            bool[,,] mogelijke_getallen = new bool[9, 9, 9];

            // Genereer de lijst voor de beginstand
            for (int x = 0; x < 9; x++)
            {
                for (int y = 0; y < 9; y++)
                {
                    if (sudoku.vakjes[x, y] != 0) continue; // Vakje is vast: skip het vakje
                    else
                    {
                        // Ga alle getallen 1-9 langs en sla legaliteit op in array
                        for (int getal = 1; getal < 10; getal++)
                        {
                            mogelijke_getallen[x, y, getal - 1] = Legaal(x, y, getal, sudoku);
                        }
                    }
                }
            }

            for (int x = 0; x < 9; x++)
            {
                for (int y = 0; y < 9; y++)
                {
                    if (sudoku.vakjes[x, y] != 0) continue; // Vakje is vast: skip het vakje
                    else
                    {
                        // Kiest het laagst mogelijke cijfer
                        for (int getal = 1; getal < 10; getal++)
                        {

                            if (mogelijke_getallen[x, y, getal - 1] == true)
                            {
                                sudoku.vakjes[x, y] = getal;
                                //updaten van de mogelijke getallen lijst na het invullen van het vakje
                                mogelijke_getallen = updateMG(sudoku, mogelijke_getallen);

                                if (check(mogelijke_getallen, sudoku) == true)
                                {
                                    break;
                                }

                                else
                                {
                                    // als een vakje geen mogelijkheden meer heeft door naar het volgende mogelijke getal
                                    continue;
                                }





                            }
                        }
                    }
                }
            }
            return true;

        }

        private static bool check(bool[,,] mogelijke_getallen, Sudoku sudoku)
        {
            for (int x = 0; x < 9; x++)
            {
                for (int y = 0; y < 9; y++)
                {
                    if (sudoku.vakjes[x, y] != 0) continue; // Vakje is vast: skip het vakje
                    else
                    {
                        //check of het vakje na de update nog mogelijke getallen bevat
                        int i = 0;
                        for (int getal = 1; getal < 10; getal++)
                        {
                            if (mogelijke_getallen[x, y, getal - 1] == false)
                            {
                                i++;
                            }

                            if (i == 9)
                            {
                                return false;
                            }



                        }
                    }
                }
            }
            return true;

        }

        private static bool[,,] updateMG(Sudoku sudoku, bool[,,] mogelijke_getallen)
        {

            for (int x = 0; x < 9; x++)
            {
                for (int y = 0; y < 9; y++)
                {
                    if (sudoku.vakjes[x, y] != 0) continue; // Vakje is vast: skip het vakje
                    else
                    {
                        // Ga alle getallen 1-9 langs en sla legaliteit op in array
                        for (int getal = 1; getal < 10; getal++)
                        {
                            mogelijke_getallen[x, y, getal - 1] = Legaal(x, y, getal, sudoku);

                        }
                    }
                }
            }
            return mogelijke_getallen;
        }

        private static bool Legaal(int x, int y, int getal, Sudoku sudoku)
        // Checkt of getal in vakje x,y van sudoku legaal zou zijn
        {
            // Check rij en kolom
            if (sudoku.Rij(y).Contains(getal)) return false;
            if (sudoku.Kolom(x).Contains(getal)) return false;

            // Check het 3x3 vak 
            // Coordinaten van de linkerbovenhoek van het vak 
            int blok_x = x - x % 3;
            int blok_y = y - y % 3;
            // Ga het vak langs vanaf de linkerbovenhoek
            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    if (sudoku.vakjes[blok_x + i, blok_y + j] == getal) return false;
                }
            }
            // Legaal
            return true;
        }
    }

    class Sudoku
    {
        // Slaat een 9x9 array van getallen op
        public int[,] vakjes;

        public Sudoku(string input)
        {
            // Parseert inputstring tot een sudoku
            vakjes = new int[9, 9];
            string[] s = input.Split(' ');
            for (int i = 0; i < s.Length - 1; i++) // Eerste element is " ", vandaar - 1
            {
                int x = i % 9;
                int y = i / 9;
                vakjes[x, y] = int.Parse(s[i + 1]); // en hier + 1
            }
        }

        public int[] Rij(int y)
        {
            // Returnt de getallen in de vakjes in de rij op y-coordinaat y
            int[] res = new int[9];
            for (int i = 0; i < 9; i++)
            {
                res[i] = vakjes[i, y];
            }
            return res;
        }

        public int[] Kolom(int x)
        {
            // Returnt de getallen in de vakjes in de kolom op x-coordinaat x
            int[] res = new int[9];
            for (int i = 0; i < 9; i++)
            {
                res[i] = vakjes[x, i];
            }
            return res;
        }

        public override string ToString()
        {
            // "tekent" de sudoku
            string res = "";

            res += "-------------------------";
            for (int i = 0; i < 3; i++)
            {
                res += "\n";
                for (int j = 0; j < 3; j++)
                {
                    res += "|";
                    for (int k = 0; k < 3; k++)
                    {
                        res += " ";
                        for (int l = 0; l < 3; l++)
                        {
                            int x = (27 * i + 9 * j + 3 * k + 1 * l) % 9;
                            int y = (27 * i + 9 * j + 3 * k + 1 * l) / 9;
                            res += vakjes[x, y] + " ";
                        }
                        res += "|";
                    }
                    res += "\n";
                }
                res += "-------------------------";
            }
            return res;
        }
    }
}

