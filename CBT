using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.Intrinsics.X86;


namespace CBT_sudoku
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Sudoku sudoku = new Sudoku(" 8 0 0 0 0 0 0 0 0 0 0 3 6 0 0 0 0 0 0 7 0 0 9 0 2 0 0 0 5 0 0 0 7 0 0 0 0 0 0 0 4 5 7 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 6 8 0 0 8 5 0 0 0 1 0 0 9 0 0 0 0 4 0 0");
            //Sudoku sudoku = new Sudoku(" 0 0 3 0 2 0 6 0 0 9 0 0 3 0 5 0 0 1 0 0 1 8 0 6 4 0 0 0 0 8 1 0 2 9 0 0 7 0 0 0 0 0 0 0 8 0 0 6 7 0 8 2 0 0 0 0 2 6 0 9 5 0 0 8 0 0 2 0 3 0 0 9 0 0 5 0 1 0 3 0 0");
            Console.WriteLine(sudoku);
            SudokuSolver solver = new SudokuSolver();
            solver.Solve("FC", sudoku);
        }
    }

    class SudokuSolver
    {
        static bool debug = true;
        static void p(string s) { if (debug) Console.WriteLine(s); }
        static void pd(bool[,,] domein, int x) 
        {
            if (debug)
            {
                string res = "";
                for (int yi = 0; yi < 9; yi++)
                {
                    for (int xi = 0; xi < 9; xi++)
                    {
                        res += $"  {xi},{yi}: ";
                        for (int i = 0; i < 9; i++)
                        {
                            if (domein[xi, yi, i]) res += $"{i + 1}";
                        }
                    }
                    res += "\n";
                }
                p(res);
            }
        }
        public void Solve(string methode, Sudoku sudoku)
        // Stuurt de oplossingsalgoritmes aan
        {
            // Check of de doorgevoerde methode geldig is
            if (methode != "CBT" && methode != "FC" && methode != "FCMCV") Console.WriteLine("Voer een geldige methode in");
            // Als hij geldig is, los de sudoku op met de juiste methode
            else
            {
                Stopwatch timer = new Stopwatch();
                timer.Start();
                bool oplosbaar = true;

                switch (methode)
                {
                    case "CBT":
                        oplosbaar = ChronologicalBackTrack(sudoku);
                        break;

                    case "FC":
                        oplosbaar = ForwardCheckSolve(sudoku);
                        break;

                    case "FCMCV":
                        oplosbaar = false;
                        break;
                }

                timer.Stop();
                // Print het resulaat
                if (oplosbaar)
                {
                    Console.WriteLine(sudoku);
                    Console.WriteLine($"Opgelost in {timer.ElapsedMilliseconds} ms");
                }
                else
                {
                    Console.WriteLine("geen oplossing");
                }
            }
        }

        static private bool ChronologicalBackTrack(Sudoku sudoku)
        // Stuurt CBT aan
        {
            // Begin Backtrack recursie
            return ChronologicalBackTrack(sudoku, 0, 0);
        }

        static private bool ChronologicalBackTrack(Sudoku sudoku, int x, int y)
        // Recursieve gedeelte van CBT
        {
            // Check of we voorbij het einde van de rij zijn
            if (x == 9)
            {
                // Check of we bij het einde van de sudoku zijn, dus of we klaar zijn
                if (y == 8) return true;

                // Anders naar volgende rij gaan
                y++;
                x = 0;
            }

            // Als het vakje vast is hoeven we hem niet te checken
            if (sudoku.squares[x, y] != 0) return ChronologicalBackTrack(sudoku, x + 1, y);

            // Check voor alle getallen 1-9 of het getal legaal is in het vakje
            for (int getal = 1; getal < 10; getal++)
            {
                if (IsLegaal(sudoku, getal, x, y))
                {
                    // Als het getal legaal is vullen we hem in en gaan we verder met zoeken
                    sudoku.squares[x, y] = getal;
                    if (ChronologicalBackTrack(sudoku, x + 1, y)) return true; // We zijn klaar dus return true
                }
            }

            // Geen oplossing in deze tak: zet vakje weer op 0 en return false (backtrack)
            sudoku.squares[x, y] = 0;
            return false;
        }
        

        static private bool ForwardCheckSolve(Sudoku sudoku)
        // Stuurt ForwardChecking aan
        {
            // We moeten per vakje het domein bijhouden
            bool[,,] domein = Domein(sudoku);

            // Begin recurie
            return ForwardCheck(sudoku, domein, 0, 0);
        }

        static private bool ForwardCheck(Sudoku sudoku, bool[,,] domein, int x, int y)
        // Recursive part of ForwardChecking
        {
            // Check whether we've reached the end of the row
            if (x == 9)
            {
                // Check whether we are at the last row (if we are we've found a solution)
                if (y == 8) return true;

                // Move to next row
                y++;
                x = 0;
            }
            // If the square is already filled we skip it
            if (sudoku.squares[x, y] != 0) return ForwardCheck(sudoku, domein, x + 1, y);

            bool[,,] domein_kopie = (bool[,,])domein.Clone();

            // Iterate over domain of square x,y
            for (int number = 0; number < 9; number++)
            {
                if (domein[x, y, number])
                {
                    // Put number in sudoku
                    sudoku.squares[x, y] = number + 1;
                    // Pass through updated domain
                    if (ForwardCheck(sudoku, UpdateDomain(sudoku, domein, number, x, y), x + 1, y)) return true;
                    domein = (bool[,,])domein_kopie.Clone();
                }
            }
            // No solution found: reset square
            sudoku.squares[x, y] = 0;
            return false;
        }

        static private bool[,,] UpdateDomain(Sudoku sudoku, bool[,,] domain, int number, int x, int y)
        // Removes number from domains of squares in the same row, column and 3x3 square as the square at x,y
        {
            for (int i = 0; i < 9; i++)
            {
                if (sudoku.squares[x, i] == 0) domain[x, i, number] = false; // Column
                if (sudoku.squares[i, y] == 0) domain[i, y, number] = false; // Row
            }

            // 3x3 square
            int square_x = x - x % 3;
            int square_y = y - y % 3;

            for (int dx = 0; dx < 3; dx++)
            {
                for (int dy = 0; dy < 3; dy++)
                {
                    if (sudoku.squares[square_x + dx, square_y + dy] == 0) domain[square_x + dx, square_y + dy, number] = false;
                }
            }

            return domain;
        }

        static private bool[,,] Domein(Sudoku sudoku)
        {
            bool[,,] domein = new bool[9, 9, 9];
            for (int x = 0; x < 9; x++)
            {
                for (int y = 0; y < 9; y++)
                {
                    if (sudoku.squares[x, y] == 0)
                    {
                        // Ga alle getallen 1-9 langs en sla legaliteit op in array
                        for (int getal = 1; getal < 10; getal++)
                        {
                            domein[x, y, getal - 1] = IsLegaal(sudoku, getal, x, y);
                        }
                    }
                }
            }
            return domein;   
        }


        static private bool IsLegaal(Sudoku sudoku, int getal, int x, int y)
        // Checkt of getal in vakje x,y van sudoku legaal zou zijn
        {
            // Check rij, kolom en 3x3 blok van het vakje: constraints
            return !(sudoku.Rij(y).Contains(getal) || sudoku.Kolom(x).Contains(getal) || sudoku.Blok(x, y).Contains(getal));
        }
    }

    class Sudoku
    {
        // Slaat een 9x9 array van getallen op
        public int[,] squares;

        public Sudoku(string input)
        {
            // Parseert inputstring tot een sudoku
            squares = new int[9, 9];
            string[] s = input.Split(' ');
            for (int i = 0; i < s.Length - 1; i++) // Eerste element is " ", vandaar - 1
            {
                int x = i % 9;
                int y = i / 9;
                squares[x, y] = int.Parse(s[i + 1]); // en hier + 1
            }
        }

        public int[] Rij(int y)
        {
            // Returnt de getallen in de vakjes in de rij op y-coordinaat y
            int[] res = new int[9];
            for (int i = 0; i < 9; i++)
            {
                res[i] = squares[i, y];
            }
            return res;
        }

        public int[] Kolom(int x)
        {
            // Returnt de getallen in de vakjes in de kolom op x-coordinaat x
            int[] res = new int[9];
            for (int i = 0; i < 9; i++)
            {
                res[i] = squares[x, i];
            }
            return res;
        }

        public int[] Blok(int x, int y)
        {
            // Returnt de getallen in het 3x3 blok van het vakje op x,y
            int[] res = new int[9];
            // Vind de linkerbovenhoek van het 3x3 blok
            int blok_x = x - x % 3;
            int blok_y = y - y % 3;
            // Ga de vakjes langs
            for (int dx = 0; dx < 3; dx++)
            {
                for (int dy = 0; dy < 3; dy++)
                {
                    res[dx * 3 + dy] = squares[blok_x + dx, blok_y + dy];
                }
            }
            return res;
        }

        public override string ToString()
        {
            // "tekent" de sudoku
            string res = "";

            res += "-------------------------";
            for (int i = 0; i < 3; i++)
            {
                res += "\n";
                for (int j = 0; j < 3; j++)
                {
                    res += "|";
                    for (int k = 0; k < 3; k++)
                    {
                        res += " ";
                        for (int l = 0; l < 3; l++)
                        {
                            int x = (27 * i + 9 * j + 3 * k + 1 * l) % 9;
                            int y = (27 * i + 9 * j + 3 * k + 1 * l) / 9;
                            res += squares[x, y] + " ";
                        }
                        res += "|";
                    }
                    res += "\n";
                }
                res += "-------------------------";
            }
            return res;
        }
    }
}
